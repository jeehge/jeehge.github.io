---
title: "CPU Scheduling"
date: 2019-12-12 18:31:42 -0400
categories: 졔 update
---

#CPU Scheduling

와 CS 스터디는 항상 맨땅에 헤딩하는 기분이라

진짜 시작이 반인 듯합니다

메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 일들의 순서를 정하는 일을 `스케줄링`이라고 합니다

제한된 자원에서 어떻게 하면 많은 프로세스를 처리할지 계획을 프로세스 스케줄링이라고 합니다

병원이라고 하면 환자가 세 명이 들어왔을 경우 감기 환자, 수술 환자, 골절 환자가 왔습니다

감기 환자는 주사, 골절 환자는 교정, 수술 환자는 수술을 해야 합니다

수술 환자를 먼저 치료하면 다른 환자들이 기다릴 테고

감기 환자를 치료해주고 골절 환자를 치료해주고 마지막으로 수술 환자를 치료하게 되면

제한된 시간에 많은 환자를 치료해 줄 수 있습니다 이런 걸 스케줄링이라고 합니다

CPU 스케줄링(CPU Scheduling)

여러 개의 CPU가 존재할 때 어떤 CPU를 처리하게 할 건지가 CPU 스케줄링이라고 합니다

하나의 CPU에서 준비 실행 대기가 실행과 준비단계를 어떻게 할 건 자기가 프로세스 스케줄링입니다

- 스케줄링은 가능한 공평성을 유지해야 합니다

- 최대한 많은 양을 처리할 수 있어야 합니다

- 응답 시간은 신속해야 합니다

- 같은 종류의 작업은 거의 같은 시간과 비용으로 실행될 수 있어야 합니다

- 오버헤드를 최소화해야 합니다

성능 평가에 대한

스케줄링 기준(Scheduling Criteria)

1) CPU 이용률(Uutilization) : CPU 수행 시간 / 시스템 구동 시간(%) ↑

=> CPU를 쉬지 않고 몇 퍼센트를 이용하는가의 기준입니다. 이용률은 최대가 되도록 해야 합니다.

2) 처리율(throughput) : 단위 시간당 완료되는 프로세스 수 ↑

=> 단위 시간당 처리할 수 있는 CPU의 작업량. 처리율은 최대한 늘려야 합니다.

3) 반환 시간(turnaround time) : 프로세스가 시스템에 진입하여 완료되기까지의 시간 ↓

=> 작업을 지시하고 그 결과가 되돌아오는 시간입니다. 반환 시간은 최소화해야 합니다.

- 기억 장치에 들어가는 시간

- 준비 큐에서 대기하는 시간

- CPU에서의 실행 시간

- 입출력 시간

4) 대기 시간(waiting time) : 준비 큐에서 대기하는 시간 ↓

=> 준비 상태에서 대기하는 시간입니다. 대기 시간은 최소화해야 합니다

- CPU 스케줄링 알고리즘에 따라 실질적으로 영향받는 요소

반응 시간(response time) : 작업을 제출한 후 응답이 나올 때까지의 시간 ↓

큐(Queue)

큐는 한 쪽에서 삽입(입력, 대기) 하고 다른 한쪽에서는 삭제(출력 처리) 하는 메모리 사용 방식의 하나로 선입 선출(FIFO) 방식으로 접근되는 대기 리스트입니다.

선형 큐(Linear Queue) : 직선 형태로 사용하는 큐

환형 큐(Circular Queue) : 원 형태로 사용하는 큐

스케줄링 알고리즘(Scheduling Algorithms)

다중 프로그래밍 방식은 메모리에 여러 개의 프로그램을 적재함으로써 CPU와 I/O 장치들의 유혹 시간을 줄여 사용 효율을 높이는 방식입니다. 이러한 다중 프로그래밍 방식에서 CPU의 사용률과 처리율을 최대로 하기 위한 방법들을 프로세스 스케줄링 알고리즘이라고 합니다

선점(Preemptive)은 한국말로 하면 '빼앗다'

비선점(Non Preemptive)은 '빼앗을 수 없다'

현재 CPU가 어떤 프로세스가 처리 중일 경우 다음 프로세스가 와서 본인이 처리될 수 있다면 '선점'

비선점은 이전 프로세스가 다 끝나고 나갈 때까지 다음 프로세스가 뺏을 수 없는 경우를 의미합니다

화장실로 예를 들어봅시다

화장실이 한 칸이 있습니다

안에 사람이 있는데 밖에 있는 친구가

안에 있는 사람을 내쫓고 본인이 들어가는 걸 선점으로 이해하면 됩니다

그럼 이 예로 비선점을 설명하려면

안에 사람이 있으니 밖에 있는 친구는 기다리는 상태! 이게 비선점입니다

비선점형 방식

FIFO(First Input First Output) == FCFS(First Come First Served)

먼저 입력된 작업을 먼저 처리하는 방식으로 가장 간단한 방법입니다

비선점 방식으로 일단 한 프로세스가 CPU를 차지하면 그 프로세스가 완성될 때까지 실행됩니다

공평하고 구현이 간단하나 평균 반환시간이 길어집니다

짧은 작업이나 중요한 작업을 오랫동안 기다릴 수도 있습니다

SJF(Shortest Job First)

작업이 끝나기까지의 실행 시간이 가장 작은 작업을 먼저 실행시키는 방식으로 비선점 방식입니다

SJF 스케줄링은 긴(크기가 큰) 작업들을 어느 정도는 희생시키면서 짧은 작업들을 우선적으로 처리하기 때문에 대기 리스트 안에 있는 작업의 수를 최소화하면서 평균 반환 시간을 최소화할 수 있습니다

주의할 점은 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리를 한다는 것입니다 하지만 긴 작업인 경우에는 계속해서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고 무한 연기 상태가 발생하기도 합니다

HRN(Highest Response-ratio Next)

실행 시간 추정과 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 하는 단점을 보완하였으며, 서비스 시간(실행 시간 추정치)과 대기 시간의 비율을 고려한 스케줄링 방법입니다

SJF 스케줄러에서 발생할 수 있는 무한 연기 현상을 극복하려고 개발된 방식입니다

우선순위 계산 공식을 이용하여 계산된 값이 가장 큰 작업에게 우선권을 부여합니다

우선순위 계산 공식 = (대기시간 + 서비스 시간) / 서비스 시간

우선순위 스케줄링(Priority Scheduling)

대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법입니다

SJF 스케줄링도 작업량이 적은 작업에 우선순위를 부여했으므로 우선순위 스케줄링의 한 예라고 볼 수 있습니다

우선순위는 처음 순위가 부여되면 절대 변하지 않는 고정적 우선순위가 있고 상황 변동에 잘 적응하며 정해진 우선순위를 계속해서 상황에 맞게 조정하는 동적 우선순위 방식이 있습니다

동적 우선순위 방식은 구현하기 어렵고 복잡하며 고정적 우선순위보다 오버헤드가 큽니다

기한부(Deadline)

제한된 시간 내에 반드시 작업이 완료되도록 스케줄링하는 방식으로 작업이 완료되는 제한된 시간을 정확히 추정하여 그 시간만큼의 CPU 사용 시간을 제한합니다

작업이 제한 시간 내에 처리되지 않으면 다시는 해당 작업이 완료되는 시기를 정확히 추정하기 힘들며 기한부 작업들이 한꺼번에 활성화(Active)가 된다면 스케줄링은 더욱 복잡해지고 막대한 오버헤드가 발생할 수 있기 때문에 주의 깊게 계획하고 사용해야 합니다

SJF나 우선순위 스케줄링에서 발생할 수 있는 무한 연기 상태, 기아 상태를 예방할 수 있습니다

무한 연기 상태, 기아 상태를 해결하기 위해 할당되기를 오랜 시간 동안 기다린 프로세스는 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법을 에이징(Aging) 기법이라고 합니다

선점형 방식

RR(Round Robin)

프로세스 스케줄링 방법 중 시분할 시스템을 위해 고안되었습니다

먼저 입력된 작업을 먼저 처리해 주는 비선점형 방식인 FIFO 스케줄링을 선점형으로 변환한 방식입니다

프로세스가 CPU에서 할당한 시간이 경과할 때까지 작업을 완료하지 못하면 CPU는 다음 대기 중인 프로세스에게로 사용 권한이 넘어가고 현재 실행 중이던 프로세스는 대기 리스트의 가장 뒤로 배치됩니다

할당되는 시간이 클 경우 FIFO 스케줄링과 같아지고 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생하게 됩니다

SRT(Shortest Remaining Time)

비선점 SJF 스케줄링을 선점형으로 변환한 방식입니다

현재 실행 중인 프로세스의 남은 시간과 대기 리스트에 새로 추가된 프로세스의 실행 시간을 비교해 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU 사용 권한을 주는 방식입니다

서비스 받은 시간을 기록해야 하기 때문에 오버헤드가 늘어납니다

평균 대기 시간과 대기 시간의 분산도 큽니다

실행 시간을 추적해야 하므로 오버헤드가 증가합니다


셀 전체 선택
0열 선택0열 다음에 열 추가
1열 선택1열 다음에 열 추가
0행 선택0행 다음에 행 추가
1행 선택1행 다음에 행 추가
열 너비 조절
행 높이 조절
SJF

SRT

- 작업 시간이 끝나기까지의 실행 시간이 가장 작은 프로세스를 먼저 실행시키는 방식

- 해당 작업이 실행되면 작업을 중단할 수 없는 비선점 방식

- 응답 시간을 예측할 수 없어 시간 분할 시스템에 적용하기 어려움

- 작업 시간이 끝나기까지의 "남아 있는" 실행 시간이 가장 작은 프로세스를 먼저 실행시키는 방식

- 해당 작업이 실행되면 작업을 중단할 수 있는 선점 방식

- 응답 시간을 예측할 수 있어 시간 분할 시스템에 유용

셀 병합
행 분할
열 분할
너비 맞춤
삭제
다단계 큐(Multi level Queue)

선점형, 비선점형 방식

기억 장치 요구량, 프로세스 우선순위, 프로세스 유형과 같은 프로세스들의 특성에 따라 여러 준비 상태 큐 중에서 한곳에 넣고 각 큐마다 고유의 스케줄링 알고리즘을 채택하는 방식입니다

다단계 피드백 큐 스케줄링(Multil evel Feedback Queue , MFQ)

짧은 작업이나 입출력 위주의 작업에 우선권을 부여하기 위해 개발된 방식입니다

프로세스가 들어가는 큐가 고정되지 않고 큐 사이를 이동 가능하게 함으로써, 서로 다른 CPU 버스트 특성을 가진 프로세스들을 분리시킬 수 있는 방식입니다

줄줄이 정리하고 보니

정보처리기사 시험 준비한 것 같은 기분이 듭니다

그땐 계산식이 정말 중요했는데

지금은 스케줄링 방법에 대해서 좀 이해하려고 노력한 것 같아서 똑똑해진 기분이 듭니다

다중 처리기 스케줄링(Multiple-processor Scheduling)

지금까지 공부한 방법은 단일 처리기 시스템을 스케줄 하는 문제에 초점을 두고 익힌 겁니다

그렇다면 여러 개의 CPU가 있는 다중 처리기 시스템에서의 CPU 스케줄링도 알아봐야 합니다

단일 처리기 시스템(single-processor system)

하나의 CPU를 사용하는 시스템

다중 처리기 시스템(multiprocessor system)

여러 개의 CPU를 사용하는 시스템

병렬 시스템

다중 처리기 시스템의 형태에 따라

비대칭적 다중 처리(asymmetric multiprocessing, ASMP)

다수의 처리기 중에 master 처리기가 존재 (주인)

나머지 처리기는 master 처리기에 의해 제어됨 (시키는 일 함)

대칭적 다중 처리(symmetric multiprocessing, SMP)

처리기가 평등함 (주종 관계없음)

처리기 친화성(Processor Affinity)

대칭 다중 처리기를 살펴보면 각 처리기가 독자적으로 프로세스를 처리하므로 특정 처리기에서 다른 처리기로 프로세스가 이동하면 각 처리기의 캐시에 해당 프로세스의 정보가 적재되게 될 것입니다. 그렇게 된다면 전에 있던 처리기의 캐시에 있던 정보가 삭제되고 이동한 처리기의 캐시가 채워져야 하는데 이는 큰 비용을 초래합니다. 때문에 대부분의 SMP 시스템은 한 처리기에서 다른 처리기의 이주를 피하고 대신 같은 처리기에서 프로세스를 실행시키려고 하는데 이러한 성질을 처리기 친화성이라고 합니다. 즉, 프로세스가 현재 실행 중인 처리기에 친화성을 가지는 것을 말합니다

부하 균등화(Load Balancing)

다중 처리기 스케줄링에서는 처리기가 여러 개이기 때문에 각각의 처리기가 균등하게 사용되는 것이 매우 중요합니다. 이렇게 각 처리기에 부하가 잘 분산되는 것은 부하 균등화라고 부릅니다. 공용 실행 큐만 있는 시스템에서는 한 처리기가 쉬게 되면 바로 공용 큐에서 프로세스를 불러와 실행하므로 문제가 없습니다. 하지만 현대의 대부분의 컴퓨터들은 자신만의 전용 큐를 가지고 있기 때문에 각 처리기가 별도의 큐에서 프로세스를 가져와서 실행하게 됩니다.

이렇게 자신만의 전용 큐를 가지고 있는 처리기의 경우 push 이주(migration)과 pull 이주(migration)을 통해 부하를 분산합니다. 푸시 이주의 경우는 부하가 높은 처리기가 프로세스를 다른 처리기로 넘기는 것을 말하며, pull 이주의 경우는 한가한 처리기가 바쁜 처리기의 프로세스를 가져오는 것을 의미합니다.

스레드 스케줄링

스레드는 경량 프로세스라고 일컬어지며, CPU가 처리하는 task의 최소한의 단위가 됩니다

이러한 스레드와 프로세스의 차이는 바로 공유하는 메모리 공간의 차이인데,

프로세스는 stack과 heap을 모두 공유하지 않기 때문에 서로 다른 프로세스를 메모리 공간을 공유하지 않으며

때문에 여러 프로세스 사이의 통신은 매우 어렵습니다

반면, 스레드는 stack은 공유하지 않고 따로 존재하며 heap는 공유하기 때문에 같은 메모리 공간을 공유합니다

즉, 각 스레드는 공통된 변수 및 메모리 공간에 접근이 가능하기 때문에 쉽게 통신할 수 있으나 다른 작업 큐를 가지기 때문에 병렬적으로 처리되어 병렬성을 가질 수 있습니다

여러 개의 스레드는 CPU에 할당되는 시점에 CPU 친화성을 가지고 할당되기 때문에 가급적 하나의 CPU에서 처리됩니다

우린 스레드를 공부했습니다

기억이 안 난다 싶으면 다시 공부하기 옵니다


[CS] 스레드, thread이미지 썸네일 삭제
[CS] 스레드, thread
​​앞에서 프로세스에 대해서 나름 꼼꼼하게 본 것 같은데 뭐 혼자 공부하면서 제가 다르게 이해한 부분이...

blog.naver.com

** 참고사이트


운영체제 | CPU 스케줄링 - Jake.Lee's Blog
운영체제 | CPU 스케줄링 CPU 스케줄링이란 무엇인가? 프로세스는 어떤 식으로 동작하나요? CPU 스케줄링은 누가 수행하나요? 스케줄링의 방법들 누가 프로세스에게 제어권을 주나요? 스케줄링의 기준 스케줄링 알고리즘 선입 선처리 스케줄링 최단 작업 우선 스케줄링 우선 순위 스케줄링 라운드 로빈 스케줄링 다단계 큐 스케줄링 다단계 피드백 큐 스케줄링 다중 처리기 스케줄링 다중 처리기 시스템에 대한 접근방법 처리기 친화성 부하 균등화 대칭적 다중 스레딩(SMT: Symmetric Multi-Threading) 스레드 스케줄링 CPU ...

frontalnh.github.io


전송중...
사진 설명을 입력하세요.

﻿
