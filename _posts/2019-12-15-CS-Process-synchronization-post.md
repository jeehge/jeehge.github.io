---
title: "프로세스 동기화"
date: 2019-12-15 10:11:40 -0400
categories: 졔 update
---




원래는 목차를 하나하나 다 조사했는데 막상 조사하다 보니 이게 다 필요할까란 생각에 실제로 내가 iOS 개발하면서 무엇이 필요할까란 생각과 함께 조금 나와 가까운 친구들에 대한 정보로 조사하기로 맘을 먹고 **오늘도 공부해봅시다!!!**

우선 프로세스 동기화 왜? 왜 때문에 알아야 하는지부터 파악해 봅시다

앞에서 프로세스와 스레드를 익혀버렸지요 `크으 👍`

동기화는 무엇일까요?


[<img width="450" src="/assets/images/post_cs/cs01.png" alt="동기화 사전의미">](https://ko.dict.naver.com/#/entry/koko/c87745f72cd7428889a06f982a904e4a)



우리는 어렵지 않게 검색을 통해 동기화의 의미를 알 수 있습니다

뭐 세상 사람들이 뜻을 다 알고 있어야겠습니까? (허허)

검색하면 다 나오는 세상에 사는데 (허허) (머쓱)

동기화라는 것은 컴퓨터 작업들 사이의 수행 시기를 맞추는 것!

두 객체의 시간을 맞춘다 ~라고 하면 되겠네요

동기화의 뜻은 그렇고 근데 우리가 알고 싶은 동기화는 그게 아니잖아요

실제로 OS에서 동기화라는 게 내가 실제로 개발하면서 동기화가 어디 쓰이나 이게 궁금한 거 아니겠습니까?

(저와 모두 생각이 같길 원합니다 🙏)



프로세스 실행에서 동기화가 필요한 그 순간은 아래와 같습니다

1. 코드 실행 순서의 일치

2. 데이터 전달(통신)

3. 공유 데이터의 갱신

이렇게 세 가지 경우가 있습니다

하지만 제가 오늘 알아볼 동기화는 세 번째 공유 데이터의 갱신 이것만 알아보려고 합니다. 왜냐고요?

우리가 지금부터 알아볼 동기화라는 친구는 두 가지 의미를 가지고 있습니다

첫 번째, 여러 개의 프로세스들이 실행 순서를 맞추는

두 번째, 프로세스들이 한 가지 자원, 한 가지 데이터!!!! 메모리를 공유할 때 그 데이터가 엉망이 되지 않도록 일관성을 맞추는

이 두 가지 개념으로 정의할 수가 있는디요



사실 제가 궁금한 동기화라고 하면 두 번째 개념과 가깝기 때문에 두 번째만 알아보려고 합니다

첫 번째 개념에 대해서도 검색해보면 많이 나옵니다 (세상엔 똑똑이들이 넘쳐나니까요!)

지금 저에겐 두 번째 개념이 필요한 것 같아서 지금부터 자세하게 알아봅시다!!



졔뱅크가 있습니다

뱅크라는 것을 보아하니 🤔 은행이겠군요!

졔뱅크에 졔가 계좌가 있습니다

졔 계좌엔 10000원이 있습니다 (호우 예!!!) 😆

근데 오늘 휴대폰비가 빠져나가는 날이네요 (또륵)

제 계좌에서 5000원이 빠져나갈 거예요

동시에 제가 오늘 설문조사비를 받아서 1000원을 입금할 거예요

그렇다면 저의 계좌엔 얼마가 있어야 할까요??

당근 6000원이 있어야겠죠?

어떠한 데이터에 대해 동시 작업이 일어날 경우 처리 순서와 상관없이 원하는 결괏값을 얻기 위해 동기화를 하는 겁니다

여러분 은행에서 돈이 빠져나가는 것과 입금을 동시에 했다고 내 잔고가 달라지면 얼~마나 속상하겠습니까



**동기화의 목적은 데이터 일관성(Data Consistency)을 보장해주는 것입니다**

이렇게 우리는 프로세스 동기화가 필요합니다

그리고 위와 같은 문제를 임계 구역 문제라고 합니다



## 임계 구역(Critical Section)

멀티 프로세스 환경에서 둘 이상의 프로세스가 동시에 접근해서는 안 되는 공유 자원의 코드 영역입니다

임계 구역 문제를 해결하기 위한 3가지 조건

임계 구역에서 발생하는 문제들은 3가지 조건을 충족시키면 해결할 수 있습니다

1. 상호배제(Mutual Exclusion)

2. 진행(Progress)

3. 한정 대기(Bounded Waiting)


첫 번째 상호배제가 보존되어야 합니다

특정 프로세스가 임계 구역에 들어가면 다른 프로세스는 들어갈 수 없어야 한다는 것이겠죠!

두 번째 진행 요구 사항이 충족되어야 합니다

누군가 임계 구역을 사용하지 않고 있다면, 다른 프로세스가 접근할 수 있도록 해야 합니다

세 번째 무한정 대기는 없어야 합니다

모든 프로세스가 임계 구역에 들어가기 위한 기회를 가질 수 있도록 해야 합니다

한 프로세스만 임계 구역에 계속 들어가게 되면 결국 다른 프로세스는 기아 현상을 겪게 되니까요




## 피터슨의 알고리즘(Peterson's Algorithm)

이 알고리즘은 flag와 turn이라고 하는 두 개의 변수를 사용합니다

flag는 말 그대로 깃발 즉 신호를 나타냅니다

내가 이 공유 자원을 쓰고 싶어!라고 표현하기 위한 변수입니다

turn도 마찬가지 차례를 의미하므로 누구 차례인지 명시해주는 변수라고 이해하면 됩니다


```
// n개의 프로세스가 있을 때, i번째 프로세스의 피터슨 알고리즘 구조도 입니다
do {
  flag[i] = true;  
   // 자 먼저 내가 임계영역에 들어가고 싶으니까 나 쓰고 싶다고 신호를 알려야겠죠? 
   //i프로세스가 지금 사용하고 싶어! 라는 의미를 전달하기 위해 flag를 true로 바꿔줍니다.

  turn = j;
  //내가 들어가고 싶다고 선언해주고 j차례로 돌려줌으로써, 
  //혹시 쓰고 싶은 다른 프로세스가 있나 확인합니다.
  //만약 다른 프로세스(ex j)가 이 공유 자원을 쓰고 싶어서 
  //7번까지 실행한 상태(j입장에서는 flag[j]=true; turn = i; 까지 실행한 상태)라면 
  //i프로세스가 j프로세스로 차례를 넘겨주자마자 16라인 코드(while)를 수행하고 임계영역에 들어가겠죠! 
  //즉 내가 쓰기 전에 먼저 쓰고 싶어했던 애가 있는 지 
  //확인하고 수행시켜주는 코드가 7번 라인입니다.

  while (flag[j] && turn == j); //전에 배운거 복습~ --> 얘가 바로 busy waits이죠!
  //임계영역에 들어가기 위해서는 당연히 내 차례여야 해요 
  //즉 turn==j일 경우 내 차례가 아닌데 j가 자원까지 쓰고 싶어한다면 
  // 나는 spinlock에서 머물어야 합니다.
  //반면에 내 차례거나 j가 자원을 쓰고 싶지 않은 경우(flag[j]==false) 
  //이제 spinlock을 빠져나와 진입할 수 있어요
  //이렇게 turn과 flag변수를 이용해서 동시 접근을 막는 거예요. 
  
  --critical section  //드디어 내가 쓰고 싶었던 자원에 와서 쿵짝쿵짝 

  flag[i]=false;  // 다 쓰고 나면 나는 다썼으니까! flag신호를 false로 바꿔줘요 

  --remainder section

} while (true);
```


## 세마포어(Semaphore)

세마포어에 대해서 재미난 이야기를 봐서 이게 딱이다 싶어서 줍줍해왔습니다

아래 참고사이트에 적어놨으니 가서 자세히 보고 오셔도 될 것 같습니다

세마포어는 깃발이라는 뜻입니다

옛날에 기찻길에서 깃발 표식으로 파란색이 걸려있으면 지나가도 되고 빨간색이 걸려있으면 섰다가 다른 기차가 지나가면 지나가게끔 하는 용도로 사용했다고 합니다

이 깃발을 세마포어라고 불렀다네요

그러니가 기찻길을 보면 하나만 있는 게 아니라 여러 길이 있잖아요

그 기찻길이 겹치는 그 부분을 임계 구역이라고 생각하면 될 것 같습니다

기찻길이 겹치는 부분을 두 기차가 양보 없이 그냥 직진해버리면 쾅 해버리지 않겠습니까!

[링크](https://jhnyang.tistory.com/101) 들어가 보면 그림도 있어서 이해하는데 더 쉬울 것 같으니 이해가 잘 안된다면 함 보고 오세요!



자 그럼 이야기에서 본론으로 돌아와서!!!!

세마포어는 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것입니다

그리고 세마포어는 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있습니다

일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 유닉스 시스템의 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술입니다

자 그럼 예를 함 들어봅시다

졔가 식당을 오픈했습니다 😆

첫 식당이기 때문에 테이블이 다섯 개밖에 없습니다

하지만 입소문이 나서 사람들이 오픈 시간에 맞춰 줄을 섭니다

오늘도 역시나 손님들이 줄 서 있군요! 후훗

졔식당 테이블 수 5

첫 번째 손님부터 1번 테이블로 안내해주고

졔식당 테이블 수 4

졔식당 테이블 수 3

졔식당 테이블 수 2

졔식당 테이블 수 1

졔식당 테이블 수 0

순서대로 손님을 안내해줬습니다

졔식당 테이블 수가 0이 되어서

여섯 번째 손님부터는 기다려야 합니다 (또륵)

요거시 세마포어입니다

세마포어는 1이면 임계 구역에 실행 중 프로세스가 없음을 의미하고 0이면 임계 구역에 실행 중 프로세스가 있음을 의미합니다

헤헿 s = 0 이네 s = 1이네 이렇게 설명이 많이 되어 있는데 위 설명으로 완벽하게 이해가 될 거라 생각합니다

왜냐면 저도 이해한 것 같으니까요!!! 하하하!!!!

세마포어를 찾다 보니 뮤텍스라는 친구가 함께 많이 나오더라고요!

또 그냥 넘어가면 평생 모를 것 같으니 정리해봅시다!



## 뮤텍스(Mutex)

상호배제(Mutual Exclusion)라고도 불립니다

임계 영역을 가진 스레드들의 실행 시간이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술입니다

다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용합니다

즉, 쉽게 말하면 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다는 의미입니다

뮤텍스도 세마포어의 일종입니다

다만! 무언가를 가지고 있어야 공유 자원에 접근할 수 있다는 게 다른 것 같습니다

뮤텍스는 어떤 오브젝트를 소유한 스레드, 프로세스 만 공유자원에 접근할 수 있게 하는 겁니다

위에서 설명했던 졔식당으로 예를 들어보고 싶었는데 유일한 키라는 부분에서 의미가 달라진 것 같아서 제가 보고 배운 예로 그냥 설명해 드리겠습니다

이 식당은 카운터에서 키를 가지고 가야 화장실을 이용 가능합니다

다음 손님을 위해 키는 다시 카운터에 돌려놔야겠죠


화장실이 급해서 카운터에서 열쇠를 들고 화장실에 갑니다!

그리고 화장실을 사용하고 있는데 다른 손님도 화장실을 이용하고 싶으면!!! 카운터에서 키가 돌아오길 기다려야겠죠?

키가 있어야 화장실에 갈 수 있으니까요

이것을 뮤텍스라고 설명합니다

공유자원에 대한 접근 권한, Lock이라는 키를 한 개만 가지고 있는 것이 뮤텍스입니다

반면 Lock이라는 키를 여러 개 가질 수 있는 것은 세마포어입니다

세마포어는 내가 가지고 있는 것에서 하나씩 빼서 0일 때 사용 못 하게 하고 기다리는 거니까요!

여기서 주의해야 할 점은 Lock에 대한 소유권은 열쇠를 획득한 사람만 반납할 수 있습니다

와 진짜 찾아보면서 설명 보면 생각보다 짧고 간단해서 금방 이해할 줄 알았는데 쉽게 이해가 되지 않아서 한참 찾아보고 이해하는데 일주일은 넘게 걸린 것 같습니다

지금까지 알아본 이것만으로 데이터 무결성을 보장할 수 없답니다 (또륵)

데드락이 발생할 수도 있지만 상호배제를 위한 기본적인 기법이고 여기에 좀 더 복잡한 메커니즘을 사용하여 프로그램을 짤 수 있으니 지금까지 알고자 노력한 걸 뿌듯하게 생각하십쇼

왜냐면 전 뿌듯하니까요



[<img width="250" src="/assets/images/avatar.jpg" alt="졔로운블로그">](https://blog.naver.com/taerg89)
